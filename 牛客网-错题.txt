牛客网错题   day1

1） 下列代码运行结果是
        public class A implements B extends C{
		     public static void main(String args[]){
			      System.out.println("hello sunline!");
			 }
		}
	编译出错！ 因为： 先继承，再实现接口
	

2）  Math类中的3个取整方法
          ceil：天花板，向上取整 ；
		  floor： 地板， 向下取整 ；
		  round：四舍五入，+0.5后再向下取整 。
		  
		  
3）  Java数据库连接库JDBC用到哪种设计模式?
        桥接模式
		
		
4）  下面哪个标识符是合法的？
           "9HelloWorld"  ：错，不能以字母开头
		   "_Hello World"  ：错 ，不能有空格
		   "Hello*World"   ：错 ， 不能有*
		   "Hello$World"  ：正确
	java的变量名有三种元素构成：数字+字符+$+下划线  不能有空格
	
	
5）  引用变量被final修饰之后，不能再指向其他对象，它指向的对象的内容也是不可变的。
      上面这句话是错的。
	  因为：使用 final 关键字修饰一个变量时，是指引用变量不能变，
	  引用变量所指向的对象中的内容还是可以改变的。
	  
	
牛客网错题  day2

1） socket编程中，以下哪个socket的操作是不属于服务端操作的（）？
        accept
	    listen
		connect
		close
	 accept、listen、close是服务端 ；
	 connect、 close是客户端 。
	 
2） 以下哪个式子有可能在某个进制下成立（）？
     13*14=204
	 解：设是在n进制下，
	         （1*n+3）*(1*n+4) =2*n^2+0*n+4 
		解这个方程，可得n=8/-1 所以，在8进制下可以成立。
		
3） public class Test
{
    static boolean foo(char c)
    {
        System.out.print(c);
        return true;
    }
    public static void main( String[] argv )
    {
        int i = 0;
        for ( foo('A'); foo('B') && (i < 2); foo('C'))
        {
            i++ ;
            foo('D');
        }
    }
}
What is the result?
        ABDCBDCB
		ABCDABCD
		Compilation fails.
		An exception is thrown at runtime.
	解析：考for循环的执行顺序，1.先执行初始化条件，2.执行判断条件，3.如果满足2的条件，执行循环体中代码；4.执行foo('c'), 5.初始化条件不在执行，友从2开始执行

	
	
******************************************************************************************************************************
牛客网错题  day3

1） 下面的程序执行输出几个hello？
#include<stdio.h>
#include <unistd.h>
int main( ) {
    fork( );
    fork( );
    fork( );
    printf(“hello\n”);
    return 0;
}
 解析：fork调用的一个奇妙之处就是它仅仅被调用一次，却能够返回两次，它可能有三种不同的返回值： 
    1）在父进程中，fork返回新创建子进程的进程ID；
    2）在子进程中，fork返回0；
    3）如果出现错误，fork返回一个负值；
	
	这个题目是这样的：
fork( );
fork( );
fork( );
三条创建子进程的语句，第一句fork()之后，就存在两个进程了，
两个进程继续往下执行，同理 第二个fork()之后，就存在2*2=4个进程了，
再继续往下，到第三个fork()之后，程序当中就已经存在2*4=8个进程了，每个进程输出一句hello。


2）  分布式系统CAP理论
    
	   分布式领域CAP理论，
Consistency(一致性), 数据一致更新，所有数据变动都是同步的
Availability(可用性), 好的响应性能
Partition tolerance(分区容错性) 可靠性

定理：任何分布式 系统只可同时满足二点，没法三者兼顾。
忠告：架构师不要将精力浪费在如何设计能满足三者的完美分布式 系统，而是应该进行取舍


3）  网络延迟指的是 指各式各样的数据在 网络介质 中通过 网络协议 (如TCP/IP)进行传输， 在 传输介质 中传输所用的时间，即从 报文 开始进入网络到它开始离开网络之间的时间。

     往返时延RTT ：  往返时延：在计算机网络中它是一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认），总共经历的时延。
	 
	 
4）  微xiao'xing服务
        1. 什么是微服务？
		   微服务，就是一种设计思想 ：专注于单一责任的小型模块，通过API互相通信，从而完成复杂的业务系统。
		   
		   
		   
		   
****************************************************************************************************************************		   
*********************************************************************************************************************************		   
牛客网错题  day4

1） 经过强制类型转换以后，变量a，b的值分别为多少？
         short a =128；
         byte b =(byte) a；
		 
	解析：
         首先 java中 是以补码表示一个数 ;
		 short 占两个字节 ，16位，128 换成二进制的形式 是 00000000 10000000，byte 占用一个字节，short 强转为byte前面八位 截掉;
		 变成 10000000，这是补码，先转换成反码，反码 = 补码 - 1，所以反码是 01111111，再求源码 10000000，因为是负数，所以等于-128.
		 
		 
2）  子类A继承父类B, A a = new A(); 则父类B构造函数、父类B静态代码块、父类B非静态代码块、子类A构造函数、子类A静态代码块、子类A非静态代码块 执行的先后顺序是？

     解析：实例化子类对象时，首先要加载父类的class文件进内存，而静态代码块是随着类的创建而执行的，所以父类的静态代码块最先被执行；
	       然后子类的class文件被加载，同样子类的静态代码块先被执行 ；
		   实例化子类对象时，要先调用父类的构造方法，而调用父类的构造方法时，先要调用父类的非静态代码块。
		   所以，顺序是：
		      父类的静态代码块 -> 子类的静态代码块 -> 父类的非静态代码块 -> 父类的构造方法 -> 子类的非静态代码块 -> 子类的构造方法
			  
			  
			  
3） 在双向链表中指针p的结点前插入一个指针q的结点操作是()
       p->Llink=q;q->Rlink=p;p->Llink->Rlink=q;q->Llink=q;
	   p->Llink=q;p->Llink->Rlink=q;q->Rlink=p;q->Llink=p->Llink;
	   q->Rlink=p;q->Llink=p->Llink;p->Llink->Rlink=q;p->Llink=q;
	   q->Llink=p->Llink;q->Rlink=q;p->Llink=q;p->Llink=q;
	   
	   解析：答案：C
                    链表的插入注意要先插入再断开
                    A，B选项中p->Llink=q操作之后就丢失了左节点
                    D中p->Llink=q;p->Llink=q;只更新了左节点，未更新右节点
					
					
**************************************************************************************************************************
**************************************************************************************************************************
牛客网  day5

1）  Java标识符由数字、字母、下划线(_)、美元符号($)或人民币(¥)组成，首位不能是数字。并且Java关键字不能作为标识符。

2）  下列哪些方法是不合法的定义？
        float func0()
　　    {
　　　　byte i=1;
　　　　return i;
　　    }         //byte字节型转换为float，正确
 
        float func1()
　　    {
　　　　int i=1;
　　　　return;
　　    }           //int转换为float，却没有返回值，错误

        float func2()
　　    {
　　　　short i=2;
　　　　return i;
　　    }            //short类型转换为float，正确

        float func3()
　　{
　　　　long i=3;
　　　　return i;
　　}                //long长整形转换为float，也是正确的。

         float func4()
　　{
　　　　double i=4;
　　　　return i;
　　}                  //double转换为float，错误

    解析：数据类型的转换，分为自动转换和强制转换。自动转换是程序在执行过程中 “ 悄然 ”  进行的转换，不需要用户提前声明，一般是从位数低的类型向位数高的类型转换；强制类型转换则必须在代码中声明，转换顺序不受限制。
    自动数据类型转换
    自动转换按从低到高的顺序转换。不同类型数据间的优先关系如下： 
               低 ---------------------------------------------> 高 
                byte,short,char-> int -> long -> float -> double
				
				
3）    public class Enclosingone {
             //非静态内部类
              public class InsideOne {}
             //静态内部类
              public static class InsideTwo{}
       }
 
        class Mytest02{
             public static void main(String args []){
                   Enclosingone.InsideOne obj1 = new Enclosingone().new InsideOne();//非静态内部类对象
                   Enclosingone.InsideTwo obj2 = new Enclosingone.InsideTwo();//静态内部类对象
    }
}




4）   对于文件的描述正确的是
          文本文件是以“.txt”为后缀名的文件，其他后缀名的文件是二进制文件。
		  File类是Java中对文件进行读写操作的基本类。
		  无论文本文件还是二进制文件，读到文件末尾都会抛出EOFException异常。
		  Java中对于文本文件和二进制文件，都可以当作二进制文件进行操作。
		  
		  解析：A. 表述有误。应当说都是二进制文件，只是编码不同而已。
		        B. File类是java中文件和目录路径名的抽象表示形式。Java中对文件进行读写操作的基本类是IO类。
				C. C:读到文件末尾不会抛出异常。EOFException：当输入过程中意外到达文件或流的末尾时，抛出此异常。
				
				
5)    java 的字符类型采用的是 Unicode 编码方案，每个 Unicode 码占用（）个比特位。
           解析：在java中一个unicode占2个字节（byte）。
                
				

				
				*************************************************************************************
***************************************************************************************************************
牛客网  day6

1）  在java中，如果你输入一个小数，系统默认是double类型的。比如：float f=11.1  这句申明就是错的。因为系统默认11.1是double类型，从
double类型到float类型，是要强制转化的。像这样：float f=(float) 11.1;或者 float f=11.1f ;


2)  下列代码的输出结果是_____
                 boolean b=true?false:true==true?false:true;
                 System.out.println(b);
			解析：false
			
			
*************************************************************************************************************************
************************************************************************************************************************
牛客网错题   day7

1）判断下列申明的对错：
        abstract final class HI{}     ->  错。final类是最终类，不能被继承；而abstract类只能被继承。矛盾。
		abstract private move(){}     ->  错。private修饰的属性及方法不能被子类实现，而抽象类的子类必须实现所有的抽象方法。两者冲突。
		protected private number;     ->  错。访问修饰符只能有一个，而且对象没有申明类型。
		public abstract class Car{}   ->  对。抽象类的定义。


2） 关于匿名内部类叙述正确的是
        匿名内部类的创建格式为： new 父类构造器（参数列表）|实现接口（）{
                                             //匿名内部类的类体实现
                                        }
        使用匿名内部类时，必须继承一个类或实现一个接口
        匿名内部类由于没有名字，因此不能定义构造函数
        匿名内部类中不能含有静态成员变量和静态方法	
		
		A. 匿名内部类可以继承一个基类，不可以实现一个接口    ->  错。
		B. 匿名内部类不可以定义构造器                        ->  对。
		C. 匿名内部类不能用于形参                            ->  错。可以有形参。
		
	
3） 下面有关java的一些细节问题，描述错误的是？
        构造方法不需要同步化                 ->  对。
        一个子类不可以覆盖掉父类的同步方法   ->  错。 子类可以覆盖同步方法并且可以不加syncronized		
		定义在接口中的方法默认是public的     ->  对。  
		容器保存的是对象的引用               ->  对。
		
		
4） public class IfTest{
    public static void main(string[]args){
        int x=3;
        int y=1;
        if(x=y)   //这里会出错。编译不会通过。什么错呢？ if()括号里默认是boolean类型的。x==y，这样是对的。
            System.out.println(“Not equal”);
        else
            System.out.println(“Equal”);
     }
}
  
 
5）  方法区和堆内存是线程共享的。
     程序计数器、虚拟机栈是线程隔离的。




*****************************************************************************************************
******************************************************************************************************

牛客网错题  day8

1） 下列哪个行为被打断不会导致InterruptedException? ()
         Thread.join
         Thread.sleep
         Object.wait
         Thread.suspend      
        解析：
           能抛出InterruptedException的代表方法有
                   java.lang.Object 类的 wait 方法
                   java.lang.Thread 类的 sleep 方法
                   java.lang.Thread 类的 join 方法		   
  
  
2） public class Test {
         static String x="1";
         static int y=1;
       public static void main(String args[]) {
             static int z=2;
			 /*
			      1. 此处错误。编译不能通过。为什么？ 
				  2. static修饰的变量属于类，只能定义在方法外
				  3. static是不能修饰局部变量的
				  4. 定义在方法里面的变量是局部变量
			 */
             System.out.println(x+y+z);
       }
    }
		

3)  执行语句"int a='2'"后，a的值是多少？
            A. 2	
            B. 50
            C. 49
            D. 0
        解析：  单引号''是字符类型；
                其中， '0'是48 ；'1'是49 ，依此类推
				       'A'是65 ；'B'是66 ，依此类推
					   'a'是97 ；'b'是98 ，依此类推
					   空格 ' ' 是32 
					   
					   
4） 下列哪个语句是创建数组的正确语句？
           float f[][] = new float[6][6];     -> 对。
		   float []f[] = new float[6][6];     -> 对。
		   float f[][] = new float[][6];      -> 错。后面的申明部分，第一个中括号中必须有值。
		   float [][]f = new float[6][6];     -> 对。
		   float [][]f = new float[6][];      -> 对。
		   
		   解析：数组命名时名称与[]可以随意排列，但声明的二维数组中第一个中括号中必须要有值，它代表的是在该二维数组中有多少个一维数组。






















				
		
		
		
		
		
		
		
		
		
		
		